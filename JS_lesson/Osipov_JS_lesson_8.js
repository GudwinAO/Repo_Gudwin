//Урок 8
//1. Продумать, где можно применить замыкания для практикума из седьмого урока.

/*Идеи:
1. При написании кода в парадигме функциональной - можно было бы использовать вложенные функции и замыкание для сбора всей истории воедино
2. Использовать замыкание при движении змейки - сохранять в переменную результаты вложенной функции и использовать в дальнейшем.
3. Передавать координаты в виде вложенных функций в стиле
function x(x) {
    let x = x;
    function y(y) {
        let result = [x,y];
        return result;
    return y;
Т.о. при неизменность 1 координаты можно будет отражать только движение по 1 оси.
*/

//2. Не выполняя код, ответить, что выведет браузер и почему:

//a.

if (!("a" in window)) {
    var a = 1;
}
console.log(!("a" in window));
alert(a);


// Условие if принимает аргументы tru или false и пытается привести любые значения к даннум булевым переменным
// В данном случае мы записываем условие НЕ строка а в объекте window. Условие возвращает false и мы не заходим в ветвление. Но, т.к. использована var,
// переменная а создается за счет высплытия и технически ее значение будет undefined

//b.

var b = function a(x) {
    x && a(--x);

};

alert(a());

// функция а существует внутри переменной b. Выдаст ошибку, тела функции нет. Дополнительно - мы не передали аргумент


//c.
function a(x) {
    return x * 2;
}
var a;

alert(a);

// в данном случае - вернет тело функции. Переменной a не присвоено значение.


//d.
function b(x, y, a) {
    arguments[2] = 10;
    alert(a);
}

b(1, 2, 3);

// передаем в функцию массив из 3 чисел. Тело функции - меняет 1 из аргументов (2) - на 10. Это и есть аргумент а. В алерт выдаст "10"


//e. *
function a() {
    alert(this);
}

a.call(null);

// Вернет объект windows, т.к. не использовано 'use strict'. В современном стандарте call/apply передают this «как есть».
//А в старом, без use strict, при указании первого аргумента null или undefined в call/apply, функция получает this = window